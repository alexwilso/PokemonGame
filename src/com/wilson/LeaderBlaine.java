package com.wilson;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;

public class LeaderBlaine extends Leader {
    private static final Hashtable<String, Integer> bag = new Hashtable<String, Integer>();
    private final Flareon flareon;
    private final Rapidash rapidash;
    private final Growlithe growlithe;
    private String strength;

    public LeaderBlaine(Flareon flareon, Rapidash rapidash, Growlithe growlithe) {
        super(bag);
        this.flareon = flareon;
        this.rapidash = rapidash;
        this.growlithe = growlithe;
        this.addItemToBag("Max Potion", 3);
    }

    public String getStrength() {
        return strength;
    }

    public void setStrength(String strength) {
        this.strength = strength;
    }

    public Flareon getFlareon() {
        return flareon;
    }

    public Rapidash getRapidash() {
        return rapidash;
    }

    public Growlithe getGrowlithe() {
        return growlithe;
    }
}

class BlaineAI{
        /*
    / Responsible for determining move to be used by Leader Blaine
     */
    BinaryTree binaryTree;
    private String opponentStatus;

    public BlaineAI(BinaryTree binaryTree) {
        this.binaryTree = binaryTree; }

    public String getOpponentStatus() {
        return opponentStatus;
    }

    public void setOpponentStatus(String opponentStatus) {
        this.opponentStatus = opponentStatus;
    }

    public String moveStatus(Map<Integer, String> moveResult, int key){
        return moveResult.get(key);
    }

    public int ReturnKeys(Map<Integer, String> moveResult){
        // Returns damage of move
        for ( Integer key : moveResult.keySet() ) {
            return key;
        }
        return 0;
    }

    public int BlaineAttackFlareon(LeaderBlaine leaderBlaine, Flareon flareon, String move, String enemyType){
        /*
        / Takes attack generated by search Tree result and returns damage done by attack. If move is heal, 0 is returned.
        / Sets pokemon status based on result of move.
         */
        String randomMove = "Random";
        Map<Integer, String>  blaineAttack;
        switch (move) {
            case "Max Potion":
                flareon.use_item("Max Potion");
                leaderBlaine.useItem("Max Potion");
                setOpponentStatus("Normal");
                flareon.setAttackName("Max Potion");
                leaderBlaine.setStrength("Normal");
                return 0;
            case "Fire Punch":
                // You are calling this 3 times, you only want to call once
                blaineAttack = flareon.getFirePunch().attack(enemyType);
                setOpponentStatus(moveStatus(blaineAttack,
                        ReturnKeys(blaineAttack)));
                flareon.setAttackName("Fire Punch");
                leaderBlaine.setStrength(flareon.getFirePunch().getStrength());
                return ReturnKeys(blaineAttack);
            case "Flame Charge":
                blaineAttack = flareon.getFlameCharge().attack(enemyType);
                setOpponentStatus(moveStatus(blaineAttack,
                        ReturnKeys(blaineAttack)));
                flareon.setAttackName("Flame Charge");
                leaderBlaine.setStrength(flareon.getFlameCharge().getStrength());
                return ReturnKeys(blaineAttack);
            case "Toxic":
                blaineAttack = flareon.getToxic().attack(enemyType);
                setOpponentStatus(moveStatus(blaineAttack,
                        ReturnKeys(blaineAttack)));
                flareon.setAttackName("Toxic");
                leaderBlaine.setStrength(flareon.getToxic().getStrength());
                return ReturnKeys(blaineAttack);
            case "Super Power":
                blaineAttack = flareon.getSuperPower().attack(enemyType);
                setOpponentStatus(moveStatus(blaineAttack,
                        ReturnKeys(blaineAttack)));
                flareon.setAttackName("Super Power");
                leaderBlaine.setStrength(flareon.getSuperPower().getStrength());
                return ReturnKeys(blaineAttack);
            case "Random":
                int min = 1;
                int max = 4;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (flareon.getToxic().getPp() > 0) {
                            flareon.setAttackName("Toxic");
                            randomMove = "Toxic";
                            break;} break;
                    case 2:
                        if (flareon.getFlameCharge().getPp() > 0) {
                            flareon.setAttackName("Flame Charge");
                            randomMove = "Flame Charge";
                            break;} break;
                    case 3:
                        if (flareon.getFirePunch().getPp() > 0) {
                            flareon.setAttackName("Fire Punch");
                            randomMove = "Fire Punch";
                            break;} break;
                    case 4:
                        if (flareon.getSuperPower().getPp() > 0) {
                            flareon.setAttackName("Super Power");
                            randomMove = "Super Power";
                            break;} break;
                }

                return BlaineAttackFlareon(leaderBlaine, flareon, randomMove, enemyType);
        }
        return 0;
    }


    public Map<Integer, String> CreateTreeFlareon(LeaderBlaine leaderBlaine, Flareon flareon, int enemyHealth,
                                                  String enemyType, String enemyStatus) {
        /*
        / Creates search tree based on input of flareon status and status of enemy. Calls LeaderBlaine to determine,
        / damage done with attack. Returns hashmap with string and damage as values.
         */
        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();
        if (flareon.getHealth() < 20) {
            if (leaderBlaine.getBag().get("Max Potion") > 2) {
                binaryTree.addNode(80, "Max Potion");}}

        if (enemyType.equals("Grass")) {
            if(flareon.getFlameCharge().getPp() > 0) {
                binaryTree.addNode(70, "Flame Charge");}
            if (flareon.getFirePunch().getPp() > 0) {
                binaryTree.addNode(60, "Fire Punch"); }}

        if (enemyType.equals("Rock")) {
            if(flareon.getFlameCharge().getPp() > 0) {
                binaryTree.addNode(10, "Flame Charge");}
            if (flareon.getFirePunch().getPp() > 0) {
                binaryTree.addNode(20, "Fire Punch");}}

        if (enemyHealth <= 25 && flareon.getSuperPower().getPp() > 0) {
            binaryTree.addNode(90, "Super Power");}

        if (enemyHealth <= 15 && flareon.getToxic().getPp() > 0) {
            binaryTree.addNode(100, "Toxic");}

        binaryTree.addNode(40, "Random");
        move.put(BlaineAttackFlareon(leaderBlaine, flareon, binaryTree.maxValue(binaryTree.root), enemyType), binaryTree.maxValue(binaryTree.root));
        return move;
    }

    public int BlaineAttackRapidash(LeaderBlaine leaderBlaine, Rapidash rapidash, String move, String enemyType){
        /*
        / Takes attack generated by search Tree result and returns damage done by attack. Sets pokemon status based on result of move.
         */
        String randomMove = "Random";
        Map<Integer, String>  blaineAttack;
        switch (move) {
            case "Fire Blast":
                // You are calling this 3 times, you only want to call once
                blaineAttack = rapidash.getFireBlast().attack(enemyType);
                setOpponentStatus(moveStatus(blaineAttack,
                        ReturnKeys(blaineAttack)));
                rapidash.setAttackName("Fire Punch");
                leaderBlaine.setStrength(rapidash.getFireBlast().getStrength());
                return ReturnKeys(blaineAttack);
            case "Fire Spin":
                blaineAttack = rapidash.getFireSpin().attack(enemyType);
                setOpponentStatus(moveStatus(blaineAttack,
                        ReturnKeys(blaineAttack)));
                rapidash.setAttackName("Fire Spin");
                leaderBlaine.setStrength(rapidash.getFireSpin().getStrength());
                return ReturnKeys(blaineAttack);
            case "Stomp":
                blaineAttack = rapidash.getStomp().attack(enemyType);
                setOpponentStatus(moveStatus(blaineAttack,
                        ReturnKeys(blaineAttack)));
                rapidash.setAttackName("Stomp");
                leaderBlaine.setStrength(rapidash.getStomp().getStrength());
                return ReturnKeys(blaineAttack);
            case "Bounce":
                blaineAttack = rapidash.getBounce().attack(enemyType);
                setOpponentStatus(moveStatus(blaineAttack,
                        ReturnKeys(blaineAttack)));
                rapidash.setAttackName("Bounce");
                leaderBlaine.setStrength(rapidash.getBounce().getStrength());
                return ReturnKeys(blaineAttack);
            case "Random":
                int min = 1;
                int max = 4;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (rapidash.getFireBlast().getPp() > 0) {
                            rapidash.setAttackName("Fire Blast");
                            randomMove = "Fire Blast";
                            break;} break;
                    case 2:
                        if (rapidash.getFireSpin().getPp() > 0) {
                            rapidash.setAttackName("Fire Spin");
                            randomMove = "Fire Spin";
                            break;} break;
                    case 3:
                        if (rapidash.getStomp().getPp() > 0) {
                            rapidash.setAttackName("Stomp");
                            randomMove = "Stomp";
                            break;} break;
                    case 4:
                        if (rapidash.getBounce().getPp() > 0) {
                            rapidash.setAttackName("Bounce");
                            randomMove = "Bounce";
                            break;} break;
                }

                return BlaineAttackRapidash(leaderBlaine, rapidash, randomMove, enemyType);
        }
        return 0;
    }


    public Map<Integer, String> CreateTreeRapidash(LeaderBlaine leaderBlaine, Rapidash rapidash, int enemyHealth,
                                                  String enemyType, String enemyStatus) {
        /*
        / Creates search tree based on input of rapidash's status and status of enemy. Calls Blaine Attack to determine,
        / damage done with attack. Returns hashmap with string and damage as values.
         */
        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();

        if (enemyType.equals("Grass")) {
            if(rapidash.getFireBlast().getPp() > 0) {
                binaryTree.addNode(70, "Fire Blast");}
            if (rapidash.getFireSpin().getPp() > 0) {
                binaryTree.addNode(60, "Fire Spin"); }}

        if (enemyType.equals("Rock")) {
            if(rapidash.getFireBlast().getPp() > 0) {
                binaryTree.addNode(10, "Fire Blast");}
            if (rapidash.getFireSpin().getPp() > 0) {
                binaryTree.addNode(20, "Fire Spin");}}

        if (enemyHealth <= 15 && rapidash.getStomp().getPp() > 0) {
            binaryTree.addNode(90, "Stomp");}

        if (enemyHealth <= 10 && rapidash.getBounce().getPp() > 0) {
            binaryTree.addNode(100, "Bounce");}

        binaryTree.addNode(40, "Random");
        move.put(BlaineAttackRapidash(leaderBlaine, rapidash, binaryTree.maxValue(binaryTree.root), enemyType), binaryTree.maxValue(binaryTree.root));
        return move;
    }

    public int BlaineAttackGrowlithe(LeaderBlaine leaderBlaine, Growlithe growlithe, String move, String enemyType){
        /*
        / Takes attack generated by search Tree result and returns damage done by attack. Sets pokemon status based on result of move.
         */
        String randomMove = "Random";
        Map<Integer, String>  blaineAttack;
        switch (move) {
            case "Max Potion":
                growlithe.use_item("Max Potion");
                leaderBlaine.useItem("Max Potion");
                setOpponentStatus("Normal");
                growlithe.setAttackName("Max Potion");
                leaderBlaine.setStrength("Normal");
                return 0;
            case "Fire Fang":
                // You are calling this 3 times, you only want to call once
                blaineAttack = growlithe.getFireFang().attack(enemyType);
                setOpponentStatus(moveStatus(blaineAttack,
                        ReturnKeys(blaineAttack)));
                growlithe.setAttackName("Fire Fang");
                leaderBlaine.setStrength(growlithe.getFireFang().getStrength());
                return ReturnKeys(blaineAttack);
            case "Flare Blitz":
                blaineAttack = growlithe.getFlareBlitz().attack(enemyType);
                setOpponentStatus(moveStatus(blaineAttack,
                        ReturnKeys(blaineAttack)));
                growlithe.setAttackName("Flare Blitz");
                leaderBlaine.setStrength(growlithe.getFlareBlitz().getStrength());
                return ReturnKeys(blaineAttack);
            case "Roar":
                blaineAttack = growlithe.getRoar().attack(enemyType);
                setOpponentStatus(moveStatus(blaineAttack,
                        ReturnKeys(blaineAttack)));
                growlithe.setAttackName("Roar");
                leaderBlaine.setStrength(growlithe.getRoar().getStrength());
                return ReturnKeys(blaineAttack);
            case "Bite":
                blaineAttack = growlithe.getBite().attack(enemyType);
                setOpponentStatus(moveStatus(blaineAttack,
                        ReturnKeys(blaineAttack)));
                growlithe.setAttackName("Bite");
                leaderBlaine.setStrength(growlithe.getBite().getStrength());
                return ReturnKeys(blaineAttack);
            case "Random":
                int min = 1;
                int max = 4;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (growlithe.getFlareBlitz().getPp() > 0) {
                            growlithe.setAttackName("Flare Blitz");
                            randomMove = "Flare Blitz";
                            break;} break;
                    case 2:
                        if (growlithe.getFireFang().getPp() > 0) {
                            growlithe.setAttackName("Fire Fang");
                            randomMove = "Fire Fang";
                            break;} break;
                    case 3:
                        if (growlithe.getRoar().getPp() > 0) {
                            growlithe.setAttackName("Roar");
                            randomMove = "Roar";
                            break;} break;
                    case 4:
                        if (growlithe.getBite().getPp() > 0) {
                            growlithe.setAttackName("Bite");
                            randomMove = "Bite";
                            break;} break;
                }

                return BlaineAttackGrowlithe(leaderBlaine, growlithe, randomMove, enemyType);
        }
        return 0;
    }


    public Map<Integer, String> CreateTreeGrowlithe(LeaderBlaine leaderBlaine, Growlithe growlithe, int enemyHealth,
                                                   String enemyType, String enemyStatus) {
        /*
        / Creates search tree based on input of growlith's status and status of enemy. Calls Blaine Attack to determine,
        / damage done with attack. Returns hashmap with string and damage as values.
         */
        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();

        if (growlithe.getHealth() < 20) {
            if (leaderBlaine.getBag().get("Max Potion") > 0) {
                binaryTree.addNode(80, "Max Potion");}}

        if (enemyType.equals("Grass")) {
            if(growlithe.getFireFang().getPp() > 0) {
                binaryTree.addNode(70, "Fire Fang");}
            if (growlithe.getFlareBlitz().getPp() > 0) {
                binaryTree.addNode(60, "Flare Blitz"); }}

        if (enemyType.equals("Rock")) {
            if(growlithe.getFireFang().getPp() > 0) {
                binaryTree.addNode(10, "Fire Fang");}
            if (growlithe.getFlareBlitz().getPp() > 0) {
                binaryTree.addNode(20, "Flare Blitz");}}

        if (enemyHealth <= 20 && growlithe.getBite().getPp() > 0) {
            binaryTree.addNode(90, "Bite");}

        if (enemyHealth <= 10 && growlithe.getRoar().getPp() > 0) {
            binaryTree.addNode(100, "Roar");}

        binaryTree.addNode(40, "Random");
        move.put(BlaineAttackGrowlithe(leaderBlaine, growlithe, binaryTree.maxValue(binaryTree.root), enemyType), binaryTree.maxValue(binaryTree.root));
        return move;
    }

}

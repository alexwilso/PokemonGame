package com.wilson;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;

public class LeaderSurge extends Leader {
    private static final Hashtable<String, Integer> bag = new Hashtable<String, Integer>();
    private final Pikachu pikachu;
    private final Electabuzz electabuzz;
    private Voltorb voltorb;
    private String strength;

    public LeaderSurge(Pikachu pikachu, Electabuzz electabuzz, Voltorb voltorb) {
        super(bag);
        this.pikachu = pikachu;
        this.electabuzz = electabuzz;
        this.voltorb = voltorb;
        this.addItemToBag("Max Potion", 3);
        this.addItemToBag("Antidote", 1); }

    public String getStrength() {
        return strength; }

    public void setStrength(String strength) {
        this.strength = strength; }

    public Pikachu getPikachu() {
        return pikachu;
    }

    public Electabuzz getElectabuzz() {
        return electabuzz;
    }

    public Voltorb getVoltorb() {
        return voltorb;
    }
}

class SurgeAI {
    /* Responsible for determining move to be used by Leader Surge. Creates attack tree for Pikachu, Voltorb, and
    Electabuzz to determine the attack to be used by each. */

    BinaryTree binaryTree;
    private String opponentStatus;

    public SurgeAI(BinaryTree binaryTree) { this.binaryTree = binaryTree; }

    public String getOpponentStatus() {
        return opponentStatus;
    }

    public void setOpponentStatus(String opponentStatus) {
        this.opponentStatus = opponentStatus;
    }

    public String moveStatus(Map<Integer, String> moveResult, int key) {
        return moveResult.get(key);
    }

    public int ReturnKeys(Map<Integer, String> moveResult) {
        // Returns damage of move
        for (Integer key : moveResult.keySet()) {
            return key; }
        return 0; }

    public int SurgeAttackPikachu(LeaderSurge leaderSurge, Pikachu pikachu, String move, String enemyType) {
         /* Takes attack generated by search Trees largest value and returns damage done by attack. If move is heal,
        0 is returned. Sets opponent status based on result of move.*/

        String randomMove = "Random";
        Map<Integer, String> surgeAttack;
        switch (move) {
            case "Max Potion":
                pikachu.use_item("Max Potion");
                leaderSurge.useItem("Max Potion");
                setOpponentStatus("Normal");
                pikachu.setAttackName("Max Potion");
                leaderSurge.setStrength("Normal");
                return 0;
            case "Quick Attack":
                surgeAttack = pikachu.getQuickAttack().attack(enemyType);
                setOpponentStatus(moveStatus(surgeAttack,
                        ReturnKeys(surgeAttack)));
                pikachu.setAttackName("Quick Attack");
                leaderSurge.setStrength(pikachu.getQuickAttack().getStrength());
                return ReturnKeys(surgeAttack);
            case "Thunder Shock":
                surgeAttack = pikachu.getThunderShock().attack(enemyType);
                setOpponentStatus(moveStatus(surgeAttack,
                        ReturnKeys(surgeAttack)));
                pikachu.setAttackName("Thunder Shock");
                leaderSurge.setStrength(pikachu.getThunderShock().getStrength());
                return ReturnKeys(surgeAttack);
            case "Thunder":
                surgeAttack = pikachu.getThunder().attack(enemyType);
                setOpponentStatus(moveStatus(surgeAttack,
                        ReturnKeys(surgeAttack)));
                pikachu.setAttackName("Thunder");
                leaderSurge.setStrength(pikachu.getThunder().getStrength());
                return ReturnKeys(surgeAttack);
            case "Growl":
                surgeAttack = pikachu.getGrowl().attack(enemyType);
                setOpponentStatus(moveStatus(surgeAttack,
                        ReturnKeys(surgeAttack)));
                pikachu.setAttackName("Growl");
                leaderSurge.setStrength(pikachu.getGrowl().getStrength());
                return ReturnKeys(surgeAttack);
            case "Random":
                int min = 1;
                int max = 4;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (pikachu.getQuickAttack().getPp() > 0) {
                            pikachu.setAttackName("Quick Attack");
                            randomMove = "Quick Attack";
                        break;} break;
                    case 2:
                        if (pikachu.getQuickAttack().getPp() > 0) {
                            pikachu.setAttackName("Thunder Shock");
                            randomMove = "Thunder Shock";
                        break;} break;
                    case 3:
                        if (pikachu.getThunder().getPp() > 0) {
                            pikachu.setAttackName("Thunder");
                            randomMove = "Thunder";
                        break;} break;
                    case 4:
                        if (pikachu.getGrowl().getPp() > 0) {
                            pikachu.setAttackName("Growl");
                            randomMove = "Growl";
                        break;} break; }
                return SurgeAttackPikachu(leaderSurge, pikachu, randomMove, enemyType); }
        return 0; }

    public Map<Integer, String> CreateTreePikachu(LeaderSurge leaderSurge, Pikachu pikachu, int enemyHealth, String enemyType, String enemyStatus) {
        /* Creates search tree based on input of Pikachus health and status of enemy. Calls Pikachu to determine,
        damage done with attack. Returns hashmap with string and damage as values. */

        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();

        if (pikachu.getHealth() < 20) {
            if (leaderSurge.getBag().get("Max Potion") > 0) {
                binaryTree.addNode(80, "Max Potion"); } }

        if (enemyType.equals("Water")) {
            if (pikachu.getThunder().getPp() > 0) {
                binaryTree.addNode(70, "Thunder"); }
            if (pikachu.getThunderShock().getPp() > 0) {
                binaryTree.addNode(60, "Thunder Shock"); } }
        else if (enemyType.equals("Rock")) {
            if (pikachu.getThunder().getPp() > 0) {
                binaryTree.addNode(10, "Thunder"); }
            if (pikachu.getThunderShock().getPp() > 0) {
                binaryTree.addNode(20, "Thunder Shock"); } }

        if (enemyHealth <= 10 && pikachu.getGrowl().getPp() > 0) {
            binaryTree.addNode(100, "Growl"); }

        if (enemyHealth <= 15 && pikachu.getQuickAttack().getPp() > 0) {
            binaryTree.addNode(90, "Quick Attack"); }

        binaryTree.addNode(40, "Random");
        move.put(SurgeAttackPikachu(leaderSurge, pikachu, binaryTree.maxValue(binaryTree.root), enemyType),
                binaryTree.maxValue(binaryTree.root));
        return move; }

    public int SurgeAttackVoltorb(LeaderSurge leaderSurge, Voltorb voltorb, String move, String enemyType) {
        /* Takes attack generated by search Trees largest value and returns damage done by attack. If move is heal,
        0 is returned. Sets opponent status based on result of move.*/

        String randomMove = "Random";
        Map<Integer, String> surgeAttack;
        switch (move) {
            case "Max Potion":
                voltorb.use_item("Max Potion");
                leaderSurge.useItem("Max Potion");
                setOpponentStatus("Normal");
                voltorb.setAttackName("Max Potion");
                leaderSurge.setStrength("Normal");
                return 0;
            case "Spark":
                surgeAttack = voltorb.getSpark().attack(enemyType);
                setOpponentStatus(moveStatus(surgeAttack,
                        ReturnKeys(surgeAttack)));
                voltorb.setAttackName("Spark");
                leaderSurge.setStrength(voltorb.getSpark().getStrength());
                return ReturnKeys(surgeAttack);
            case "Sonic Boom":
                surgeAttack = voltorb.getSonicBoom().attack(enemyType);
                setOpponentStatus(moveStatus(surgeAttack,
                        ReturnKeys(surgeAttack)));
                voltorb.setAttackName("Sonic Boom");
                leaderSurge.setStrength(voltorb.getSonicBoom().getStrength());
                return ReturnKeys(surgeAttack);
            case "Tackle":
                surgeAttack = voltorb.getTackle().attack(enemyType);
                setOpponentStatus(moveStatus(surgeAttack,
                        ReturnKeys(surgeAttack)));
                voltorb.setAttackName("Tackle");
                leaderSurge.setStrength(voltorb.getTackle().getStrength());
                return ReturnKeys(surgeAttack);
            case "Self Destruct":
                surgeAttack = voltorb.getSelfDestruct(true).attack(enemyType);
                setOpponentStatus(moveStatus(surgeAttack,
                        ReturnKeys(surgeAttack)));
                voltorb.setAttackName("Self Destruct");
                leaderSurge.setStrength(voltorb.getSelfDestruct(false).getStrength());
                return ReturnKeys(surgeAttack);
            case "Random":
                int min = 1;
                int max = 3;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (voltorb.getTackle().getPp() > 0) {
                            voltorb.setAttackName("Tackle");
                            randomMove = "Tackle";
                        break;} break;
                    case 2:
                        if (voltorb.getSpark().getPp() > 0) {
                            voltorb.setAttackName("Spark");
                            randomMove = "Spark";
                        break;} break;
                    case 3:
                        if (voltorb.getSonicBoom().getPp() > 0) {
                            voltorb.setAttackName("Sonic Boom");
                            randomMove = "Sonic Boom";
                        break;} break; }
                return SurgeAttackVoltorb(leaderSurge, voltorb, randomMove, enemyType); }
        return 0; }

    public Map<Integer, String> CreateTreeVoltorb(LeaderSurge leaderSurge, Voltorb voltorb, int enemyHealth, String enemyType,
                                                  String enemyStatus) {
        /* Creates search tree based on input of Voltorbs health and status of enemy. Calls VoltorbAttack to determine,
        damage done with attack. Returns hashmap with string and damage as values. */

        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();

        if (voltorb.getHealth() < 20) {
            if (leaderSurge.getBag().get("Max Potion") > 2) {
                binaryTree.addNode(80, "Max Potion"); }
            else { binaryTree.addNode(80, "Self Destruct"); } }

        if (enemyType.equals("Water")) {
            if (voltorb.getSpark().getPp() > 0) {
                binaryTree.addNode(70, "Spark"); } }
        else if (enemyType.equals("Rock")) {
            binaryTree.addNode(10, "Spark"); }

        if (enemyHealth <= 10 && voltorb.getTackle().getPp() > 0) {
            binaryTree.addNode(100, "Tackle"); }

        if (enemyHealth <= 20 && voltorb.getSonicBoom().getPp() > 0) {
            binaryTree.addNode(90, "Sonic Boom"); }

        binaryTree.addNode(40, "Random");
        move.put(SurgeAttackVoltorb(leaderSurge, voltorb, binaryTree.maxValue(binaryTree.root), enemyType),
                binaryTree.maxValue(binaryTree.root));
        return move; }

    public int SurgeAttackElectabuzz(LeaderSurge leaderSurge, Electabuzz electabuzz, String move, String enemyType) {
          /* Takes attack generated by search Trees largest value and returns damage done by attack. If move is heal,
        0 is returned. Sets opponent status based on result of move.*/

        String randomMove = "Random";
        Map<Integer, String> surgeAttack;
        switch (move) {
            case "Max Potion":
                electabuzz.use_item("Max Potion");
                leaderSurge.useItem("Max Potion");
                setOpponentStatus("Normal");
                electabuzz.setAttackName("Max Potion");
                leaderSurge.setStrength("Normal");
                return 0;
            case "Thunder":
                surgeAttack = electabuzz.getThunder().attack(enemyType);
                setOpponentStatus(moveStatus(surgeAttack,
                        ReturnKeys(surgeAttack)));
                electabuzz.setAttackName("Thunder");
                leaderSurge.setStrength(electabuzz.getThunder().getStrength());
                return ReturnKeys(surgeAttack);
            case "Thunder Punch":
                surgeAttack = electabuzz.getThunderPunch().attack(enemyType);
                setOpponentStatus(moveStatus(surgeAttack,
                        ReturnKeys(surgeAttack)));
                electabuzz.setAttackName("Thunder Punch");
                leaderSurge.setStrength(electabuzz.getThunderPunch().getStrength());
                return ReturnKeys(surgeAttack);
            case "Quick Attack":
                surgeAttack = electabuzz.getQuickAttack().attack(enemyType);
                setOpponentStatus(moveStatus(surgeAttack,
                        ReturnKeys(surgeAttack)));
                electabuzz.setAttackName("Quick Attack");
                leaderSurge.setStrength(electabuzz.getQuickAttack().getStrength());
                return ReturnKeys(surgeAttack);
            case "Low Kick":
                surgeAttack = electabuzz.getLowKick().attack(enemyType);
                setOpponentStatus(moveStatus(surgeAttack,
                        ReturnKeys(surgeAttack)));
                electabuzz.setAttackName("Low Kick");
                leaderSurge.setStrength(electabuzz.getLowKick().getStrength());
                return ReturnKeys(surgeAttack);
            case "Random":
                int min = 1;
                int max = 4;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (electabuzz.getLowKick().getPp() > 0) {
                            electabuzz.setAttackName("Low Kick");
                            randomMove = "Low Kick";
                        break;} break;
                    case 2:
                        if (electabuzz.getQuickAttack().getPp() > 0) {
                            electabuzz.setAttackName("Quick Attack");
                            randomMove = "Quick Attack";
                        break;} break;
                    case 3:
                        if (electabuzz.getThunder().getPp() > 0) {
                            electabuzz.setAttackName("Thunder");
                            randomMove = "Thunder";
                        break;} break;
                    case 4:
                        if (electabuzz.getThunderPunch().getPp() > 0) {
                            electabuzz.setAttackName("Thunder Punch");
                            randomMove = "Thunder Punch";
                        break;} break; }
                return SurgeAttackElectabuzz(leaderSurge, electabuzz, randomMove, enemyType); }
        return 0; }

    public Map<Integer, String> CreateTreeElectabuzz(LeaderSurge leaderSurge, Electabuzz electabuzz, int enemyHealth, String enemyType,
                                                     String enemyStatus) {
        /* Creates search tree based on input of Electabuzz's health and status of enemy. Calls ElectabuzzAttack to determine,
        damage done with attack. Returns hashmap with string and damage as values. */

        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();
        if (electabuzz.getHealth() < 20) {
            if (leaderSurge.getBag().get("Max Potion") > 1) {
                binaryTree.addNode(80, "Max Potion"); } }

            if (enemyType.equals("Water")) {
                if (electabuzz.getThunder().getPp() > 0) {
                    binaryTree.addNode(60, "Thunder"); }
                if (electabuzz.getThunderPunch().getPp() > 0) {
                    binaryTree.addNode(70, "Thunder Punch"); } }
            else if (enemyType.equals("Rock")) {
                binaryTree.addNode(10, "Thunder");
                binaryTree.addNode(10, "Thunder Punch"); }

            if (enemyHealth <= 10 && electabuzz.getQuickAttack().getPp() > 0) {
                binaryTree.addNode(100, "Quick Attack"); }

            if (enemyHealth <= 15 && electabuzz.getLowKick().getPp() > 0) {
                binaryTree.addNode(90, "Low Kick"); }

            binaryTree.addNode(40, "Random");
            move.put(SurgeAttackElectabuzz(leaderSurge, electabuzz, binaryTree.maxValue(binaryTree.root), enemyType),
                    binaryTree.maxValue(binaryTree.root));
            return move; }
}

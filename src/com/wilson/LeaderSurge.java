package com.wilson;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;

public class LeaderSurge extends Leader {
    private final Pikachu pikachu;
    private final Electabuzz electabuzz;
    private Voltorb voltorb;

    public LeaderSurge(Hashtable<String, Integer> bag, Pikachu pikachu, Electabuzz electabuzz, Voltorb voltorb) {
        super(bag);
        this.pikachu = pikachu;
        this.electabuzz = electabuzz;
        this.voltorb = voltorb;
        this.addItemToBag("Max Potion", 2);
    }


    public Pikachu getPikachu() {
        return pikachu;
    }

    public Electabuzz getElectabuzz() {
        return electabuzz;
    }

    public Voltorb getVoltorb() {
        return voltorb;
    }
}

class SurgeAI{
    /*
    / Responsible for determining move to be used by Leader Surge
     */

    BinaryTree binaryTree = new BinaryTree();
    private String opponentStatus;

    public String getOpponentStatus() {
        return opponentStatus;
    }

    public void setOpponentStatus(String opponentStatus) {
        this.opponentStatus = opponentStatus;
    }

    public String moveStatus(Map<Integer, String> moveResult, int key){
        return moveResult.get(key);
    }

    public int ReturnKeys(Map<Integer, String> moveResult){
        // Returns damage of move
        for ( Integer key : moveResult.keySet() ) {
            return key;
        }
        return 0;
    }

    public int SurgeAttackPikachu (LeaderSurge leaderSurge, Pikachu pikachu, String move, String enemyType){
        /*
        / Takes attack generated by search Tree result and returns damage done by attack. If move is heal, 0 is returned.
        / Sets pokemon status based on result of move.
         */
        String randomMove = "Random";
        switch (move) {
            case "Max Potion":
                pikachu.use_item("Max Potion");
                leaderSurge.useItem("Max Potion");
                break;
            case "Quick Attack":
                setOpponentStatus(moveStatus(pikachu.getQuickAttack().attack(enemyType),
                        ReturnKeys(pikachu.getQuickAttack().attack(enemyType))));
                return ReturnKeys(pikachu.getQuickAttack().attack(enemyType));
            case "Thunder Shock":
                setOpponentStatus(moveStatus(pikachu.getThunderShock().attack(enemyType),
                        ReturnKeys(pikachu.getThunderShock().attack(enemyType))));
                return ReturnKeys(pikachu.getThunderShock().attack(enemyType));
            case "Thunder":
                setOpponentStatus(moveStatus(pikachu.getThunder().attack(enemyType),
                        ReturnKeys(pikachu.getThunder().attack(enemyType))));
                return ReturnKeys(pikachu.getThunder().attack(enemyType));
            case "Growl":
                setOpponentStatus(moveStatus(pikachu.getGrowl().attack(enemyType),
                        ReturnKeys(pikachu.getGrowl().attack(enemyType))));
                return ReturnKeys(pikachu.getGrowl().attack(enemyType));
            case "Random":
                int min = 1;
                int max = 4;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (pikachu.getQuickAttack().getPp() > 0) {
                            randomMove = "Quick Attack";
                            break;} break;
                    case 2:
                        if (pikachu.getQuickAttack().getPp() > 0) {
                            randomMove = "Thunder Shock";
                            break;} break;
                    case 3:
                        if (pikachu.getThunder().getPp() > 0) {
                            randomMove = "Thunder";
                            break;} break;
                    case 4:
                        if (pikachu.getGrowl().getPp() >0) {
                            randomMove = "Growl";
                            break;} break;
                }

                return SurgeAttackPikachu(leaderSurge, pikachu, randomMove, enemyType);
        }
        return 0;
    }
    public Map<String, Integer> CreateTreePikachu(LeaderSurge leaderSurge, Pikachu pikachu, int enemyHealth, String enemyType, String enemyStatus) {
         /*
        / Creates search tree based on input of pikachu status and status of enemy. Calls SurgeAttack to determine,
        / damage done with attack. Returns hashmap with string and damage as values.
         */
        Map<String, Integer> move = new HashMap<>();
        if (pikachu.getHealth() < 20) {
            if (leaderSurge.getBag().get("Max Potion") > 1) {
                binaryTree.addNode(70, "Max Potion");
            } else {
                binaryTree.addNode(0, "Max Potion");
            }
            if (enemyType.equals("Water")) {
                binaryTree.addNode(70, "Thunder");
                binaryTree.addNode(60, "Thunder Shock");
            } else if (enemyType.equals("Rock")) {
                binaryTree.addNode(10, "Thunder");
                binaryTree.addNode(10, "Thunder Shock");
            }
            if (enemyHealth <= 10) {
                binaryTree.addNode(100, "Growl");
            }
            if (enemyHealth <= 15) {
                binaryTree.addNode(90, "Quick Attack");
            }

            binaryTree.addNode(40, "Random");
        }
        move.put(binaryTree.maxValue(binaryTree.root), SurgeAttackPikachu(leaderSurge, pikachu, binaryTree.maxValue(binaryTree.root), enemyType));
        return move;
    }
}
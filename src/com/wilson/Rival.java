package com.wilson;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;

public class Rival extends Leader{
    private static final Hashtable<String, Integer> bag = new Hashtable<>();
    private final Object[] pokeballs = new Object[3];
    private String name;
    private String strength;

    public Rival(String name) {
        super(bag);
        this.name = name;
        this.addItemToBag("Potion", 0);
        this.addItemToBag("Max Potion", 0);
    }

    public Hashtable<String, Integer> getBag() {
        return bag;
    }

    public void setPokemon(Object pokemon, int number) {
        this.pokeballs[number] = pokemon;
    }

    public Object[] getPokemon() {
        return pokeballs;
    }

    public String getStrength() {
        return strength; }

    public void setStrength(String strength) {
        this.strength = strength; }

    public String getName() {
        return name;
    }
}

class RivalAI{
     /* Responsible for determining move returned from Rival. Pokemon are based on user selection */
    BinaryTree binaryTree;
    private String opponentStatus;

    public RivalAI(BinaryTree binaryTree) {
        this.binaryTree = binaryTree; }

    public String getOpponentStatus() {
        return opponentStatus;
    }

    public void setOpponentStatus(String opponentStatus) {
        this.opponentStatus = opponentStatus;
    }

    public String moveStatus(Map<Integer, String> moveResult, int key){
        return moveResult.get(key);
    }

    public int ReturnKeys(Map<Integer, String> moveResult){
        // Returns damage of move
        for ( Integer key : moveResult.keySet() ) {
            return key; }
        return 0; }

    public int RivalAttackBulbasaur(Rival rival, Bulbasaur bulbasaur, String move, String enemyType){
        /* Takes attack generated by search Trees largest value and returns damage done by attack. If move is heal,
        0 is returned. Sets opponent status based on result of move.*/

        String randomMove = "Random";
        Map<Integer, String>  rivalAttack;
        switch (move) {
            case "Max Potion":
                bulbasaur.use_item("Max Potion");
                rival.useItem("Max Potion");
                setOpponentStatus("Normal");
                bulbasaur.setAttackName("Max Potion");
                rival.setStrength("Normal");
                return 0;
            case "Vine Whip":
                rivalAttack = bulbasaur.getVineWhip().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                bulbasaur.setAttackName("Vine Whip");
                rival.setStrength(bulbasaur.getVineWhip().getStrength());
                return ReturnKeys(rivalAttack);
            case "Razor Leaf":
                rivalAttack = bulbasaur.getRazorLeaf().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                bulbasaur.setAttackName("Razor Leaf");
                rival.setStrength(bulbasaur.getRazorLeaf().getStrength());
                return ReturnKeys(rivalAttack);
            case "Sludge Bomb":
                rivalAttack = bulbasaur.getSludgeBomb().attack();
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                bulbasaur.setAttackName("Sludge Bomb");
                rival.setStrength(bulbasaur.getVineWhip().getStrength());
                return ReturnKeys(rivalAttack);
            case "Leech Seed":
                rivalAttack = bulbasaur.getLeechSeed(true).attack();
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                bulbasaur.setAttackName("Leech Seed");
                rival.setStrength(bulbasaur.getLeechSeed(false).getStrength());
                return ReturnKeys(rivalAttack);
            case "Random":
                int min = 1;
                int max = 4;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (bulbasaur.getVineWhip().getPp() > 0) {
                            bulbasaur.setAttackName("Vine Whip");
                            randomMove = "Vine Whip";
                            break;} break;
                    case 2:
                        if (bulbasaur.getRazorLeaf().getPp() > 0) {
                            bulbasaur.setAttackName("Razor Leaf");
                            randomMove = "Razor Leaf";
                            break;} break;
                    case 3:
                        if (bulbasaur.getLeechSeed(false).getPp() > 0) {
                            bulbasaur.setAttackName("Leech Seed");
                            randomMove = "Leech Seed";
                            break;} break;
                    case 4:
                        if (bulbasaur.getSludgeBomb().getPp() > 0) {
                            bulbasaur.setAttackName("Sludge Bomb");
                            randomMove = "Sludge Bomb";
                            break;} break; }
                return RivalAttackBulbasaur(rival, bulbasaur, randomMove, enemyType); }
        return 0; }


    public Map<Integer, String> CreateTreeBulbasaur(Rival rival, Bulbasaur bulbasaur, int enemyHealth,
                                                     String enemyType, String enemyStatus) {
        /* Creates search tree based on input of bulbasaur health and status of enemy. Calls BulbasaurAttack to
        determine, damage done with attack. Returns hashmap with string and damage as values. */

        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();
        if (bulbasaur.getHealth() < 20) {
            if (rival.getBag().get("Max Potion") > 0) {
                binaryTree.addNode(90, "Max Potion");}}

        if (enemyType.equals("Rock") || enemyType.equals("Water")) {
            if(bulbasaur.getVineWhip().getPp() > 0) {
                binaryTree.addNode(70, "Vine Whip");}
            if (bulbasaur.getRazorLeaf().getPp() > 0) {
                binaryTree.addNode(60, "Razor Leaf"); }}

        if (enemyType.equals("Flying") || enemyType.equals("Fire")) {
            if(bulbasaur.getVineWhip().getPp() > 0) {
                binaryTree.addNode(10, "Vine Whip");}
            if (bulbasaur.getRazorLeaf().getPp() > 0) {
                binaryTree.addNode(20, "Razor Leaf");}}

        if (enemyHealth <= 10 && bulbasaur.getSludgeBomb().getPp() > 0) {
            binaryTree.addNode(100, "Sludge Bomb");}

        if (enemyHealth <= 20 && bulbasaur.getLeechSeed(false).getPp() > 0) {
            binaryTree.addNode(95, "Leech Seed");}

        binaryTree.addNode(40, "Random");
        move.put(RivalAttackBulbasaur(rival, bulbasaur, binaryTree.maxValue(binaryTree.root), enemyType),
                binaryTree.maxValue(binaryTree.root));
        return move; }

    public int RivalAttackSquirtle(Rival rival, Squirtle squirtle, String move, String enemyType){
        /* Takes attack generated by search Trees largest value and returns damage done by attack. If move is heal,
        0 is returned. Sets opponent status based on result of move.*/

        String randomMove = "Random";
        Map<Integer, String>  rivalAttack;
        switch (move) {
            case "Max Potion":
                squirtle.use_item("Max Potion");
                rival.useItem("Max Potion");
                setOpponentStatus("Normal");
                squirtle.setAttackName("Max Potion");
                rival.setStrength("Normal");
                return 0;
            case "Shell Attack":
                rivalAttack = squirtle.getShellAttack().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                squirtle.setAttackName("Shell Attack");
                rival.setStrength(squirtle.getShellAttack().getStrength());
                return ReturnKeys(rivalAttack);
            case "Hydro Pump":
                rivalAttack = squirtle.getHydroPump().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                squirtle.setAttackName("Hydro Pump");
                rival.setStrength(squirtle.getHydroPump().getStrength());
                return ReturnKeys(rivalAttack);
            case "Surf":
                rivalAttack = squirtle.getSurf().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                squirtle.setAttackName("Surf");
                rival.setStrength(squirtle.getSurf().getStrength());
                return ReturnKeys(rivalAttack);
            case "Tackle":
                rivalAttack = squirtle.getTackle().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                squirtle.setAttackName("Tackle");
                rival.setStrength(squirtle.getTackle().getStrength());
                return ReturnKeys(rivalAttack);
            case "Random":
                int min = 1;
                int max = 4;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (squirtle.getHydroPump().getPp() > 0) {
                            squirtle.setAttackName("Hydro Pump");
                            randomMove = "Hydro Pump";
                            break;} break;
                    case 2:
                        if (squirtle.getSurf().getPp() > 0) {
                            squirtle.setAttackName("Surf");
                            randomMove = "Surf";
                            break;} break;
                    case 3:
                        if (squirtle.getTackle().getPp() > 0) {
                            squirtle.setAttackName("Tackle");
                            randomMove = "Tackle";
                            break;} break;
                    case 4:
                        if (squirtle.getShellAttack().getPp() > 0) {
                            squirtle.setAttackName("Shell Attack");
                            randomMove = "Shell Attack";
                            break;} break; }
                return RivalAttackSquirtle(rival, squirtle, randomMove, enemyType); }
        return 0; }


    public Map<Integer, String> CreateTreeSquirtle(Rival rival, Squirtle squirtle, int enemyHealth,
                                                    String enemyType, String enemyStatus) {
        /* Creates search tree based on input of squirtle health and status of enemy. Calls SquirtleAttack to
        determine, damage done with attack. Returns hashmap with string and damage as values. */

        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();
        if (squirtle.getHealth() < 20) {
            if (rival.getBag().get("Max Potion") > 0) {
                binaryTree.addNode(90, "Max Potion");}}

        if (enemyType.equals("Rock") || enemyType.equals("Fire")) {
            if(squirtle.getSurf().getPp() > 0) {
                binaryTree.addNode(60, "Surf");}
            if (squirtle.getHydroPump().getPp() > 0) {
                binaryTree.addNode(70, "Hydro Pump"); }}

        if (enemyType.equals("Water") || enemyType.equals("Grass")) {
            if(squirtle.getHydroPump().getPp() > 0) {
                binaryTree.addNode(10, "Surf");}
            if (squirtle.getSurf().getPp() > 0) {
                binaryTree.addNode(20, "Hydro Pump");}}

        if (enemyHealth <= 10 && squirtle.getTackle().getPp() > 0) {
            binaryTree.addNode(100, "Tackle");}

        if (enemyHealth <= 15 && squirtle.getShellAttack().getPp() > 0) {
            binaryTree.addNode(95, "Shell Attack");}

        binaryTree.addNode(40, "Random");
        move.put(RivalAttackSquirtle(rival, squirtle, binaryTree.maxValue(binaryTree.root), enemyType),
                binaryTree.maxValue(binaryTree.root));
        return move; }

    public int RivalAttackGengar(Rival rival, Gengar gengar, String move, String enemyType){
        /* Takes attack generated by search Trees largest value and returns damage done by attack. If move is heal,
        0 is returned. Sets opponent status based on result of move.*/

        String randomMove = "Random";
        Map<Integer, String>  rivalAttack;
        switch (move) {
            case "Max Potion":
                gengar.use_item("Max Potion");
                rival.useItem("Max Potion");
                setOpponentStatus("Normal");
                gengar.setAttackName("Max Potion");
                rival.setStrength("Normal");
                return 0;
            case "Confusion Ray":
                rivalAttack = gengar.getConfusionRay().attack();
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                gengar.setAttackName("Confusion Ray");
                rival.setStrength(gengar.getConfusionRay().getStrength());
                return ReturnKeys(rivalAttack);
            case "Lick":
                rivalAttack = gengar.getLick().attack();
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                gengar.setAttackName("Lick");
                rival.setStrength(gengar.getLick().getStrength());
                return ReturnKeys(rivalAttack);
            case "Poison Jab":
                rivalAttack = gengar.getPoisonJab().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                gengar.setAttackName("Poison Jab");
                rival.setStrength(gengar.getPoisonJab().getStrength());
                return ReturnKeys(rivalAttack);
            case "Shadow Ball":
                rivalAttack = gengar.getShadowBall().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                gengar.setAttackName("Shadow Ball");
                rival.setStrength(gengar.getShadowBall().getStrength());
                return ReturnKeys(rivalAttack);
            case "Random":
                int min = 1;
                int max = 4;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (gengar.getConfusionRay().getPp() > 0) {
                            gengar.setAttackName("Confusion Ray");
                            randomMove = "Confusion Ray";
                            break;} break;
                    case 2:
                        if (gengar.getLick().getPp() > 0) {
                            gengar.setAttackName("Lick");
                            randomMove = "Lick";
                            break;} break;
                    case 3:
                        if (gengar.getPoisonJab().getPp() > 0) {
                            gengar.setAttackName("Poison Jab");
                            randomMove = "Poison Jab";
                            break;} break;
                    case 4:
                        if (gengar.getShadowBall().getPp() > 0) {
                            gengar.setAttackName("Shadow Ball");
                            randomMove = "Shadow Ball";
                            break;} break; }
                return RivalAttackGengar(rival, gengar, randomMove, enemyType); }
        return 0; }


    public Map<Integer, String> CreateTreeGengar(Rival rival, Gengar gengar, int enemyHealth,
                                                   String enemyType, String enemyStatus) {
        /* Creates search tree based on input of gengar health and status of enemy. Calls GengarAttack to
        determine, damage done with attack. Returns hashmap with string and damage as values. */

        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();
        if (gengar.getHealth() < 20) {
            if (rival.getBag().get("Max Potion") > 0) {
                binaryTree.addNode(90, "Max Potion");}}

        if (enemyType.equals("Rock") || enemyType.equals("Ghost")) {
            if(gengar.getShadowBall().getPp() > 0) {
                binaryTree.addNode(60, "Shadow Ball");}
            if (gengar.getPoisonJab().getPp() > 0) {
                binaryTree.addNode(70, "Poison Jab"); }}

        if (enemyHealth <= 10 && gengar.getLick().getPp() > 0) {
            binaryTree.addNode(100, "Lick");}

        if (enemyHealth <= 20 && gengar.getConfusionRay().getPp() > 0) {
            binaryTree.addNode(95, "Confusion Ray");}

        binaryTree.addNode(40, "Random");
        move.put(RivalAttackGengar(rival, gengar, binaryTree.maxValue(binaryTree.root), enemyType),
                binaryTree.maxValue(binaryTree.root));
        return move; }

    public int RivalAttackOnix(Rival rival, Onix onix, String move, String enemyType){
        /* Takes attack generated by search Trees largest value and returns damage done by attack. If move is heal,
        0 is returned. Sets opponent status based on result of move.*/

        String randomMove = "Random";
        Map<Integer, String>  rivalAttack;
        switch (move) {
            case "Max Potion":
                onix.use_item("Max Potion");
                rival.useItem("Max Potion");
                setOpponentStatus("Normal");
                onix.setAttackName("Max Potion");
                rival.setStrength("Normal");
                return 0;
            case "Rock Smash":
                rivalAttack = onix.getRockSmash().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                onix.setAttackName("Rock Smash");
                rival.setStrength(onix.getRockSmash().getStrength());
                return ReturnKeys(rivalAttack);
            case "Bind":
                rivalAttack = onix.getBind().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                onix.setAttackName("Bind");
                rival.setStrength(onix.getBind().getStrength());
                return ReturnKeys(rivalAttack);
            case "Rage":
                rivalAttack = onix.getRage().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                onix.setAttackName("Rage");
                rival.setStrength(onix.getRage().getStrength());
                return ReturnKeys(rivalAttack);
            case "Rock Throw":
                rivalAttack = onix.getRockThrow().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                onix.setAttackName("Rock Throw");
                rival.setStrength(onix.getRockThrow().getStrength());
                return ReturnKeys(rivalAttack);
            case "Random":
                int min = 1;
                int max = 4;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (onix.getRockSmash().getPp() > 0) {
                            onix.setAttackName("Rock Smash");
                            randomMove = "Rock Smash";
                            break;} break;
                    case 2:
                        if (onix.getBind().getPp() > 0) {
                            onix.setAttackName("Bind");
                            randomMove = "Bind";
                            break;} break;
                    case 3:
                        if (onix.getRockThrow().getPp() > 0) {
                            onix.setAttackName("Rock Throw");
                            randomMove = "Rock Throw";
                            break;} break;
                    case 4:
                        if (onix.getRage().getPp() > 0) {
                            onix.setAttackName("Rage");
                            randomMove = "Rage";
                            break;} break; }
                return RivalAttackOnix(rival, onix, randomMove, enemyType); }
        return 0; }


    public Map<Integer, String> CreateTreeOnix(Rival rival, Onix onix, int enemyHealth,
                                                 String enemyType, String enemyStatus) {
        /* Creates search tree based on input of onix health and status of enemy. Calls OnixAttack to
        determine, damage done with attack. Returns hashmap with string and damage as values. */

        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();
        if (onix.getHealth() < 20) {
            if (rival.getBag().get("Max Potion") > 0) {
                binaryTree.addNode(90, "Max Potion");}}

        if (enemyType.equals("Flying") || enemyType.equals("Fire")) {
            if(onix.getRockThrow().getPp() > 0) {
                binaryTree.addNode(60, "Rock Throw");}
            if (onix.getRockSmash().getPp() > 0) {
                binaryTree.addNode(70, "Rock Smash"); }}

        if (enemyType.equals("Rock")) {
            if(onix.getRockSmash().getPp() > 0) {
                binaryTree.addNode(10, "Rock Smash");}
            if (onix.getRockThrow().getPp() > 0) {
                binaryTree.addNode(20, "Rock Throw");}}

        if (enemyHealth <= 15 && onix.getBind().getPp() > 0) {
            binaryTree.addNode(100, "Bind");}

        if (enemyHealth <= 20 && onix.getRage().getPp() > 0) {
            binaryTree.addNode(95, " Rage");}

        binaryTree.addNode(40, "Random");
        move.put(RivalAttackOnix(rival, onix, binaryTree.maxValue(binaryTree.root), enemyType),
                binaryTree.maxValue(binaryTree.root));
        return move;}

    public int RivalAttackCharmander(Rival rival, Charmander charmander, String move, String enemyType){
        /* Takes attack generated by search Trees largest value and returns damage done by attack. If move is heal,
        0 is returned. Sets opponent status based on result of move.*/

        String randomMove = "Random";
        Map<Integer, String>  rivalAttack;
        switch (move) {
            case "Max Potion":
                charmander.use_item("Max Potion");
                rival.useItem("Max Potion");
                setOpponentStatus("Normal");
                charmander.setAttackName("Max Potion");
                rival.setStrength("Normal");
                return 0;
            case "Scratch":
                rivalAttack = charmander.getScratch().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                charmander.setAttackName("Scratch");
                rival.setStrength(charmander.getScratch().getStrength());
                return ReturnKeys(rivalAttack);
            case "Ember":
                rivalAttack = charmander.getEmber().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                charmander.setAttackName("Ember");
                rival.setStrength(charmander.getEmber().getStrength());
                return ReturnKeys(rivalAttack);
            case "Tail Whip":
                rivalAttack = charmander.getTailwhip().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                charmander.setAttackName("Tail Whip");
                rival.setStrength(charmander.getTailwhip().getStrength());
                return ReturnKeys(rivalAttack);
            case "Flamethrower":
                rivalAttack = charmander.getFlamethrower().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                charmander.setAttackName("Flamethrower");
                rival.setStrength(charmander.getFlamethrower().getStrength());
                return ReturnKeys(rivalAttack);
            case "Random":
                int min = 1;
                int max = 4;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (charmander.getTailwhip().getPp() > 0) {
                            charmander.setAttackName("Tail Whip");
                            randomMove = "Tail Whip";
                            break;} break;
                    case 2:
                        if (charmander.getScratch().getPp() > 0) {
                            charmander.setAttackName("Scratch");
                            randomMove = "Scratch";
                            break;} break;
                    case 3:
                        if (charmander.getFlamethrower().getPp() > 0) {
                            charmander.setAttackName("Flamethrower");
                            randomMove = "Flamethrower";
                            break;} break;
                    case 4:
                        if (charmander.getEmber().getPp() > 0) {
                            charmander.setAttackName("Ember");
                            randomMove = "Ember";
                            break;} break; }
                return RivalAttackCharmander(rival, charmander, randomMove, enemyType); }
        return 0; }


    public Map<Integer, String> CreateTreeCharmander(Rival rival, Charmander charmander, int enemyHealth,
                                               String enemyType, String enemyStatus) {
        /* Creates search tree based on input of charmander health and status of enemy. Calls CharmanderAttack to
        determine, damage done with attack. Returns hashmap with string and damage as values. */

        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();
        if (charmander.getHealth() < 20) {
            if (rival.getBag().get("Max Potion") > 0) {
                binaryTree.addNode(90, "Max Potion");}}

        if (enemyType.equals("Grass")) {
            if(charmander.getEmber().getPp() > 0) {
                binaryTree.addNode(60, "Ember");}
            if (charmander.getFlamethrower().getPp() > 0) {
                binaryTree.addNode(70, "Flamethrower"); }}

        if (enemyType.equals("Water") || enemyType.equals("Rock")) {
            if(charmander.getFlamethrower().getPp() > 0) {
                binaryTree.addNode(10, "Flamethrower");}
            if (charmander.getEmber().getPp() > 0) {
                binaryTree.addNode(20, "Ember");}}

        if (enemyHealth <= 10 && charmander.getTailwhip().getPp() > 0) {
            binaryTree.addNode(100, "Tail Whip");}

        if (enemyHealth <= 20 && charmander.getScratch().getPp() > 0) {
            binaryTree.addNode(95, " Scratch");}

        binaryTree.addNode(40, "Random");
        move.put(RivalAttackCharmander(rival, charmander, binaryTree.maxValue(binaryTree.root), enemyType),
                binaryTree.maxValue(binaryTree.root));
        return move; }

    public int RivalAttackPikachu(Rival rival, Pikachu pikachu, String move, String enemyType){
        /* Takes attack generated by search Trees largest value and returns damage done by attack. If move is heal,
        0 is returned. Sets opponent status based on result of move.*/

        String randomMove = "Random";
        Map<Integer, String>  rivalAttack;
        switch (move) {
            case "Max Potion":
                pikachu.use_item("Max Potion");
                rival.useItem("Max Potion");
                setOpponentStatus("Normal");
                pikachu.setAttackName("Max Potion");
                rival.setStrength("Normal");
                return 0;
            case "Thunder":
                rivalAttack = pikachu.getThunder().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                pikachu.setAttackName("Thunder");
                rival.setStrength(pikachu.getThunder().getStrength());
                return ReturnKeys(rivalAttack);
            case "Growl":
                rivalAttack = pikachu.getGrowl().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                pikachu.setAttackName("Growl");
                rival.setStrength(pikachu.getGrowl().getStrength());
                return ReturnKeys(rivalAttack);
            case "Quick Attack":
                rivalAttack = pikachu.getQuickAttack().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                pikachu.setAttackName("Quick Attack");
                rival.setStrength(pikachu.getQuickAttack().getStrength());
                return ReturnKeys(rivalAttack);
            case "Thunder Shock":
                rivalAttack = pikachu.getThunderShock().attack(enemyType);
                setOpponentStatus(moveStatus(rivalAttack,
                        ReturnKeys(rivalAttack)));
                pikachu.setAttackName("Thunder Shock");
                rival.setStrength(pikachu.getThunderShock().getStrength());
                return ReturnKeys(rivalAttack);
            case "Random":
                int min = 1;
                int max = 4;
                int random = (int) (Math.random() * (max - min + 1)) + min;
                switch (random) {
                    case 1:
                        if (pikachu.getThunder().getPp() > 0) {
                            pikachu.setAttackName("Thunder");
                            randomMove = "Thunder";
                            break;} break;
                    case 2:
                        if (pikachu.getGrowl().getPp() > 0) {
                            pikachu.setAttackName("Growl");
                            randomMove = "Growl";
                            break;} break;
                    case 3:
                        if (pikachu.getQuickAttack().getPp() > 0) {
                            pikachu.setAttackName("Quick Attack");
                            randomMove = "Quick Attack";
                            break;} break;
                    case 4:
                        if (pikachu.getThunderShock().getPp() > 0) {
                            pikachu.setAttackName("Thunder Shock");
                            randomMove = "Thunder Shock";
                            break;} break; }
                return RivalAttackPikachu(rival, pikachu, randomMove, enemyType); }
        return 0; }


    public Map<Integer, String> CreateTreePikachu(Rival rival, Pikachu pikachu, int enemyHealth,
                                                     String enemyType, String enemyStatus) {
        /* Creates search tree based on input of pikachu health and status of enemy. Calls CharmanderAttack to
        determine, damage done with attack. Returns hashmap with string and damage as values. */

        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();
        if (pikachu.getHealth() < 20) {
            if (rival.getBag().get("Max Potion") > 0) {
                binaryTree.addNode(90, "Max Potion");}}

        if (enemyType.equals("Water")) {
            if(pikachu.getThunder().getPp() > 0) {
                binaryTree.addNode(70, "Thunder");}
            if (pikachu.getThunderShock().getPp() > 0) {
                binaryTree.addNode(60, "Thunder Shock"); }}

        if (enemyType.equals("Rock")) {
            if(pikachu.getThunder().getPp() > 0) {
                binaryTree.addNode(10, "Thunder");}
            if (pikachu.getThunderShock().getPp() > 0) {
                binaryTree.addNode(20, "Thunder Shock");}}

        if (enemyHealth <= 10 && pikachu.getGrowl().getPp() > 0) {
            binaryTree.addNode(100, "Growl");}

        if (enemyHealth <= 20 && pikachu.getQuickAttack().getPp() > 0) {
            binaryTree.addNode(95, "Quick Attack");}

        binaryTree.addNode(40, "Random");
        move.put(RivalAttackPikachu(rival, pikachu, binaryTree.maxValue(binaryTree.root), enemyType),
                binaryTree.maxValue(binaryTree.root));
        return move; }
        // UNDER HERE

        public int RivalAttackPidgey(Rival rival, Pidgey pidgey, String move, String enemyType){
        /* Takes attack generated by search Trees largest value and returns damage done by attack. If move is heal,
        0 is returned. Sets opponent status based on result of move.*/

            String randomMove = "Random";
            Map<Integer, String>  rivalAttack;
            switch (move) {
                case "Max Potion":
                    pidgey.use_item("Max Potion");
                    rival.useItem("Max Potion");
                    setOpponentStatus("Normal");
                    pidgey.setAttackName("Max Potion");
                    rival.setStrength("Normal");
                    return 0;
                case "Fly":
                    rivalAttack = pidgey.getFly().attack(enemyType);
                    setOpponentStatus(moveStatus(rivalAttack,
                            ReturnKeys(rivalAttack)));
                    pidgey.setAttackName("Fly");
                    rival.setStrength(pidgey.getFly().getStrength());
                    return ReturnKeys(rivalAttack);
                case "Gust":
                    rivalAttack = pidgey.getGust().attack(enemyType);
                    setOpponentStatus(moveStatus(rivalAttack,
                            ReturnKeys(rivalAttack)));
                    pidgey.setAttackName("Gust");
                    rival.setStrength(pidgey.getGust().getStrength());
                    return ReturnKeys(rivalAttack);
                case "Peck":
                    rivalAttack = pidgey.getPeck().attack(enemyType);
                    setOpponentStatus(moveStatus(rivalAttack,
                            ReturnKeys(rivalAttack)));
                    pidgey.setAttackName("Peck");
                    rival.setStrength(pidgey.getPeck().getStrength());
                    return ReturnKeys(rivalAttack);
                case "Wing Attack":
                    rivalAttack = pidgey.getWingAttack().attack(enemyType);
                    setOpponentStatus(moveStatus(rivalAttack,
                            ReturnKeys(rivalAttack)));
                    pidgey.setAttackName("Wing Attack");
                    rival.setStrength(pidgey.getWingAttack().getStrength());
                    return ReturnKeys(rivalAttack);
                case "Random":
                    int min = 1;
                    int max = 4;
                    int random = (int) (Math.random() * (max - min + 1)) + min;
                    switch (random) {
                        case 1:
                            if (pidgey.getWingAttack().getPp() > 0) {
                                pidgey.setAttackName("Wing Attack");
                                randomMove = "Wing Attack";
                                break;} break;
                        case 2:
                            if (pidgey.getFly().getPp() > 0) {
                                pidgey.setAttackName("Fly");
                                randomMove = "Fly";
                                break;} break;
                        case 3:
                            if (pidgey.getGust().getPp() > 0) {
                                pidgey.setAttackName("Gust");
                                randomMove = "Gust";
                                break;} break;
                        case 4:
                            if (pidgey.getPeck().getPp() > 0) {
                                pidgey.setAttackName("Peck");
                                randomMove = "Peck";
                                break;} break; }
                    return RivalAttackPidgey(rival, pidgey, randomMove, enemyType); }
            return 0; }


    public Map<Integer, String> CreateTreePidgey(Rival rival, Pidgey pidgey, int enemyHealth,
                                                  String enemyType, String enemyStatus) {
        /* Creates search tree based on input of pidgey health and status of enemy. Calls PidgeyAttack to
        determine, damage done with attack. Returns hashmap with string and damage as values. */

        binaryTree.deleteTree();
        Map<Integer, String> move = new HashMap<>();
        if (pidgey.getHealth() < 20) {
            if (rival.getBag().get("Max Potion") > 0) {
                binaryTree.addNode(90, "Max Potion");}}

        if (enemyType.equals("Grass")) {
            if(pidgey.getWingAttack().getPp() > 0) {
                binaryTree.addNode(70, "Wing Attack");}
            if (pidgey.getFly().getPp() > 0) {
                binaryTree.addNode(60, "Fly"); }}

        if (enemyType.equals("Rock") || enemyType.equals("Electric")) {
            if(pidgey.getWingAttack().getPp() > 0) {
                binaryTree.addNode(10, "Wing Attack");}
            if (pidgey.getFly().getPp() > 0) {
                binaryTree.addNode(20, "Fly");}}

        if (enemyHealth <= 10 && pidgey.getPeck().getPp() > 0) {
            binaryTree.addNode(100, "Peck");}

        if (enemyHealth <= 20 && pidgey.getGust().getPp() > 0) {
            binaryTree.addNode(95, "Gust");}

        binaryTree.addNode(40, "Random");
        move.put(RivalAttackPidgey(rival, pidgey, binaryTree.maxValue(binaryTree.root), enemyType),
                binaryTree.maxValue(binaryTree.root));
        return move; }
}